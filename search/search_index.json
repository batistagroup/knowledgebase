{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Batista Group Knowledgebase","text":"<p>Welcome to the internal knowledgebase for the Batista Group at Yale University. This resource serves as a centralized repository of information, protocols, and documentation for group members.</p>"},{"location":"#about-us","title":"About Us","text":"<p>The Batista Group, led by Prof. Victor S. Batista at Yale University, focuses on cutting-edge research in theoretical and computational chemistry. Visit our official website to learn more about our research and team members.</p>"},{"location":"#resources","title":"Resources","text":""},{"location":"#github-repositories","title":"GitHub Repositories","text":"<p>Our group maintains several open-source projects and research tools on GitHub. You can find our repositories at:</p> <ul> <li>Batista Lab GitHub Organization</li> </ul>"},{"location":"#links-to-our-projects","title":"Links to our projects","text":"<ol> <li>DirectMultiStep - Direct Route Generation for Multi-Step Retrosynthesis.</li> <li>Models UI - a website to run some of our ML models directly from browser</li> </ol>"},{"location":"labels/","title":"Labels Guide","text":"<p>This document describes the labels used in our knowledgebase repository and their corresponding commit prefixes.</p>"},{"location":"labels/#labels","title":"Labels","text":""},{"location":"labels/#core-science","title":"Core Science","text":"Label Commit Prefix(es) <code>quantum-mechanics</code> <code>quantum:</code>, <code>qm:</code> <code>quantum-computing</code> <code>qc:</code> <code>quantum-dynamics</code> <code>qd:</code> <code>molecular-dynamics</code> <code>md:</code> <code>ai-ml</code> <code>ai:</code>, <code>ml:</code>"},{"location":"labels/#programming","title":"Programming","text":"Label Commit Prefix(es) <code>git</code> <code>git:</code> <code>python</code> <code>python:</code>, <code>py:</code>"},{"location":"labels/#educational","title":"Educational","text":"Label Commit Prefix(es) <code>tutorials</code> <code>tutorial:</code> <code>lectures</code> <code>lecture:</code>"},{"location":"labels/#publications","title":"Publications","text":"Label Commit Prefix(es) <code>publications</code> <code>pub:</code>"},{"location":"labels/#maintenance","title":"Maintenance","text":"Label Commit Prefix(es) <code>maintenance</code> <code>maint:</code>"},{"location":"labels/#version-impact","title":"Version Impact","text":"<p>Labels affect the version number of the next release as follows:</p>"},{"location":"labels/#major-version-bump","title":"Major Version Bump","text":"<ul> <li>Manual label <code>major</code> for major updates</li> </ul>"},{"location":"labels/#minor-version-bump","title":"Minor Version Bump","text":"<ul> <li>All core science labels</li> <li>Educational content labels</li> <li>Publications label</li> </ul>"},{"location":"labels/#patch-version-bump","title":"Patch Version Bump","text":"<ul> <li>Maintenance label</li> <li>Default for unlabeled changes</li> </ul>"},{"location":"git/git/","title":"Version Control with Git","text":"<p>Sup.</p>"},{"location":"python/essential-tools/","title":"Python Starter Pack","text":""},{"location":"python/essential-tools/#overview","title":"Overview","text":"<p>This guide provides a modern, efficient approach to Python project management using <code>uv</code>, a high-performance replacement for traditional tools like pip, pyenv, and poetry. It's designed for Python developers who want to streamline their development workflow and adopt current best practices for dependency management.</p> <p>Prerequisites</p> <ul> <li>Basic familiarity with Python and command line</li> <li>Basic understanding of virtual environments and package management</li> <li>macOS, Linux, or Windows system</li> </ul>"},{"location":"python/essential-tools/#choosing-uv-as-a-package-manager","title":"Choosing uv as a package manager","text":"<p>uv is a python project and package manager that replaces <code>pip</code>, <code>pyenv</code>, <code>poetry</code>, and mostly <code>conda</code>. It's faster, simpler, and better.</p>"},{"location":"python/essential-tools/#why-not-conda","title":"Why not conda?","text":"<p>You can have many anti-conda rants on the internet. It's bulky, it has complicated installation process that easily tricks you into installing the full anaconda suit with all the things you never need. Pragmatically, each time you create a new virtual environment, it installs a new python in that env, so if you have 5 different projects each using python 3.12.8, you will have 5 copies of python 3.12.8 installed. Why would you want that?</p>"},{"location":"python/essential-tools/#why-not-pyenv-venv","title":"Why not pyenv + venv?","text":"<p>A more reasonable alternative, until Feb 2024, was using pyenv, which installs global versions of python that you can easily switch between, and then creating <code>venv</code> using python native <code>python -m venv venv</code>. Your workflow was:</p> <pre><code>pyenv local 3.12\npython -m venv venv\nsource venv/bin/activate\n</code></pre>"},{"location":"python/essential-tools/#so-why-uv","title":"So why uv?","text":"<p>uv basically mirrors workflow above, but makes everything faster.</p> <pre><code>uv venv --python 3.12\nsource .venv/bin/activate\n</code></pre> <p>As a bonus, installing uv is incredibly easy, just one curl script that is easily found in docs without requiring you to go through 10 accordeons and tabs.</p>"},{"location":"python/essential-tools/#starting-a-new-project","title":"Starting a new project","text":"<p>After creating and <code>cd</code> into your project directory, you can run <code>uv init</code>, which will create:</p> <ul> <li><code>.python-version</code> - a simple text file specifying python version you chose when running <code>uv venv --python 3.12</code>. If a project has <code>.python-version</code> specified, you can simply run <code>uv venv</code> and it'll use (or install if that python is not installed already) python version specified in <code>.python-version</code>.</li> <li><code>pyproject.toml</code> - a modern replacement to <code>setup.py</code>, <code>requirements.txt</code>.</li> <li><code>main.py</code> - your first <code>.py</code> file.</li> </ul> <p>See python-template repo for an example of a filled <code>pyproject.toml</code>.</p>"},{"location":"python/essential-tools/#creating-your-package","title":"Creating your package","text":"<p>Choosing when to structure your code as a package is ultimately a matter of preference. As of today, I prefer to create a package from the very beginning. Simply because:</p> <ul> <li>if it's a research project, I will release the code regardless of whether it truly is a standalone package (i.e. other people will use it in their projects as a dependency) just for reproducibility reasons</li> <li>given that <code>uv</code> uses <code>pyproject.toml</code> to enumerate dependencies already, it's a matter of a few extra lines to convert codebase into a package</li> <li>having a central package removes the necessity to either explicitly add path to sys or use some complicated relative path imports. If you had these issues before, you know what I mean.</li> </ul>"},{"location":"python/essential-tools/#why-should-i-put-my-package-under-src","title":"Why should I put my package under src/","text":"<p>You might notice that python-template repo or DirectMultiStep hides the package files under <code>src/</code> directory. This is a good practice, because, if you have the following structure:</p> <pre><code>my-project/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 my_package/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 script.py\n</code></pre> <p>when you install <code>my_package</code> in development mode (e.g. <code>uv pip install -e .</code>), the project root directory (<code>my-project/</code>) is added to the python path. This means that any file in your project root can be accidentally imported as part of your package. For example, if you have a <code>script.py</code> in your project root, it could be mistakenly imported as <code>my_package.test</code>.</p> <p>By placing your package under <code>src/</code>, like this:</p> <pre><code>my-project/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 my_package/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 module.py\n\u2514\u2500\u2500 tests/\n</code></pre> <p>and configuring your <code>pyproject.toml</code> accordingly, only the <code>src/</code> directory is added to the python path during development installation. This clearly separates your package code from other project files (like configuration, tests, documentation, etc.) and prevents potential naming conflicts and accidental imports from the project root. It's a cleaner and more robust way to structure your project.</p>"},{"location":"python/essential-tools/#installing-dependencies","title":"Installing Dependencies","text":""},{"location":"python/essential-tools/#your-package","title":"Your package","text":"<p>Once you've created some package in <code>src/</code>, all that remains is to add this to your <code>pyproject.toml</code>:</p> <pre><code>[tool.setuptools]\npackages = [\"my_package\"]\npackage-dir = { \"\" = \"src\" }\n</code></pre> <p>Don't forget to activate your venv</p> <p>Once you have your project set up, your venv should be pretty much always activated. Your IDE (VSCode, Cursor) should automatically recognize presence of <code>.venv</code> folder and activate it in the terminal sessions. But if you open your repository in a standalone terminal window, you'll have to manually <code>source .venv/bin/activate</code>.</p> <p>After this, you can install your package in development mode <code>uv pip install -e .</code>. The <code>-e</code> specifies dev mode and effectively it means that any changes made to the source code in <code>src/my_package</code> will be immediately available (i.e. you don't need to reinstall your package).</p>"},{"location":"python/essential-tools/#external-dependencies","title":"External Dependencies","text":"<p>Instead of running <code>pip install package</code> you should use <code>uv add package</code>. Using <code>uv add</code> instead of <code>pip install</code> results in:</p> <ul> <li><code>package</code> added as dependency to <code>pyproject.toml</code></li> <li><code>uv.lock</code> updated</li> </ul> <p>You might find uv's docs helpful if you need to specify specific (including platform-specific) source for the package.</p>"},{"location":"python/essential-tools/#pyprojecttoml-and-uvlock","title":"pyproject.toml and uv.lock","text":"<p>At this point, you might wonder -- what is <code>uv.lock</code> and how is it different from <code>pyproject.toml</code>?</p> <p>In short:</p> <ul> <li><code>pyproject.toml</code> is a soft specification of minimal version requirements of top-level packages</li> <li><code>uv.lock</code> is a strict and full specification of all packages installed in current venv.</li> </ul> <p>As an example, if you <code>uv add</code> a package, say, SciPy, <code>pyproject.toml</code> will add <code>scipy&gt;=1.15.2.</code>, i.e. a spec of minimally required version. However, SciPy itself depends on NumPy, so NumPy will be installed in the venv and reflected in <code>uv.lock</code>, but not in <code>pyproject.toml</code>.</p> <p>In some sense, <code>uv.lock</code> is similar to what you'd get from <code>pip freeze</code>. Why do we need both <code>pyproject.toml</code> and <code>uv.lock</code>?</p> <ul> <li><code>pyproject.toml</code> is useful to keep track of which packages you intentionally added. If you want to update, say, SciPy to 1.16, you can update <code>pyproject.toml</code> and run <code>uv lock --upgrade</code>. If SciPy depends on 10 other packages, you shouldn't be required to manually update dependencies of all those packages, which is why it's all handled for you by <code>uv.lock</code>.</li> <li><code>uv.lock</code> is useful because it allows any other user to recreate your local environment exactly. You never need to manually modify this file, as long as you use <code>uv add</code>, <code>uv remove</code> to handle dependencies.</li> </ul> <p>See uv locking and syncing page for more details.</p> <p>uv.lock gives you confidence that your code will always work</p> <p>Basically, once you have a working codebase, even if you stop working on it, you (or any other human) can come back to it at any point in the future, and he'll be able to run it without any issues. Your code will work even if numpy updated 10 times in the meantime or some other package stopped being maintained. Fun fact: lock files have been a standard in web dev for almost 15 years, you might be familiar with <code>package-lock.json</code> and <code>yarn.lock</code>.</p>"},{"location":"python/essential-tools/#dependency-groups","title":"Dependency Groups","text":"<p>By default, every package you <code>uv add</code> appears as:</p> <pre><code>[project]\ndependencies = [\"numpy==1.26.4\"]\n</code></pre> <p>However, you can also have optional dependency groups:</p> <pre><code>[project.optional-dependencies]\ndev = [\"ruff&gt;=0.9.6\", \"mypy&gt;=1.15.0\"]\nweb = [\"flask&gt;=3.1.0\"]\n</code></pre> <p>which you can install by:</p> <pre><code>uv pip install -e \".[dev]\" # will install main deps and dev deps\nuv pip install -e \".[web]\" # will install main + web deps\nuv pip install -e \".[dev,web]\" # will install main + dev + web deps\n</code></pre> <p>which is useful when, say, 2 people are working on the project and only one of them develops the web-facing code. There's no reason for the other person to have all web-related dependencies in his venv, so they can be separated into a dep group.</p>"},{"location":"python/essential-tools/#migrating-from-traditional-tools","title":"Migrating from Traditional Tools","text":""},{"location":"python/essential-tools/#from-pip-venv","title":"From pip + venv","text":"<p>If you're currently using pip with venv, migration is straightforward:</p> <ol> <li> <p>Install uv: Follow the installation instructions above</p> </li> <li> <p>For existing projects:</p> <pre><code># In your project directory\nuv pip freeze &gt; requirements.txt  # Export current dependencies\ndeactivate  # Exit current venv\nrm -rf venv/  # Remove old venv\nuv venv  # Create new venv\nsource .venv/bin/activate\nuv pip install -r requirements.txt  # Install dependencies\n</code></pre> </li> <li> <p>Convert to modern structure:</p> <ul> <li>Create <code>pyproject.toml</code> using <code>uv init</code></li> <li>Move dependencies from <code>requirements.txt</code> to <code>pyproject.toml</code></li> <li>Run <code>uv pip install -e .</code> to install in editable mode</li> </ul> </li> </ol>"},{"location":"python/essential-tools/#from-conda","title":"From conda","text":"<p>For conda users, the transition requires a few additional steps:</p> <ol> <li> <p>Export your conda environment:</p> <pre><code>conda list --explicit &gt; conda-packages.txt\n</code></pre> </li> <li> <p>Identify pure Python packages from conda-packages.txt</p> </li> <li> <p>Create new project with uv:</p> <pre><code>uv venv\nsource .venv/bin/activate\n</code></pre> </li> <li> <p>Install required packages using <code>uv add</code></p> </li> <li> <p>For conda-specific packages (like MKL-optimized numpy), refer to package documentation for pip-compatible alternatives</p> </li> </ol>"},{"location":"python/essential-tools/#summary","title":"Summary","text":""},{"location":"python/essential-tools/#key-takeaways","title":"Key Takeaways","text":"<ul> <li><code>uv</code> provides a faster, simpler alternative to traditional Python tooling</li> <li>The src/ layout with pyproject.toml offers a clean, modern project structure</li> <li>Lock files ensure reproducible environments across team members and time</li> <li>Dependency groups help manage optional features efficiently</li> </ul>"},{"location":"python/essential-tools/#related-resources","title":"Related Resources","text":"<ul> <li>uv Documentation</li> <li>Python Packaging User Guide</li> <li>Batista Group Python Template</li> </ul>"},{"location":"python/tests/intro/","title":"The Art of Testing Python Code","text":"<p>Testing transforms your code from a fragile house of cards into a robust, maintainable fortress by systematically validating its behavior and documenting its intent.</p> <p>Admittedly, testing is not something I've fully embraced, I don't have (yet) a single codebase that has 90+% test coverage; however, the more I've worked on projects where more than one person writes the code, the more I understand their necessity. At the end of the day, just like with typing, it's something you need to force yourself to do once, and after that it will become a natural part of coding.</p>"},{"location":"python/tests/intro/#testing-in-the-wild","title":"Testing in the wild","text":"<p>Testing is pretty much an unquestionable industry standard. Any codebase that will be reused strives to have code coverage of at least 90% (meaning that 90% of lines of code have a test case explicitly testing them).</p> <p>Perhaps the most famous example of a well tested codebase is SQLite, a SQL based db used by Adobe, Google (Android and Chrome), Apple (iOS), Dropbox, and many other giants. SQLite library contains 155 800 lines of source code in C (excluding blanks and comments). The test suite for SQLite has 92 053 100 lines of code, i.e. 590 lines of testing for every line of code.</p> <p>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.[source]</p> <p>Python code can be tested using pytest library. The rest of this page documents basic use.</p>"},{"location":"python/tests/intro/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>Understanding of Python functions and classes</li> </ul> <pre><code>source .venv/bin/activate\nuv add pytest typing-extensions mypy\n</code></pre>"},{"location":"python/tests/intro/#testing-fundamentals","title":"Testing Fundamentals","text":""},{"location":"python/tests/intro/#1-unit-tests-the-foundation","title":"1. Unit Tests: The Foundation","text":"<p>Unit tests validate individual components in isolation. They are your first line of defense.</p> <pre><code>from typing import Any\nfrom decimal import Decimal\n\n\nclass PricingEngine:\n    \"\"\"Handles product pricing calculations.\"\"\"\n\n    def calculate_discount(self, price: Decimal, percentage: Decimal) -&gt; Decimal:\n        \"\"\"Calculate discounted price.\n\n        Args:\n            price: Original price\n            percentage: Discount percentage (0-100)\n\n        Returns:\n            Discounted price\n\n        Raises:\n            ValueError: If percentage is not between 0 and 100\n        \"\"\"\n        if not 0 &lt;= percentage &lt;= 100:\n            raise ValueError(\"Percentage must be between 0 and 100\")\n        return price * (1 - percentage / 100)\n\n\ndef test_pricing_engine() -&gt; None:\n    \"\"\"Demonstrate comprehensive unit testing.\"\"\"\n    engine = PricingEngine()\n\n    # Happy path\n    assert engine.calculate_discount(Decimal(\"100.00\"), Decimal(\"20.00\")) == Decimal(\n        \"80.00\"\n    )\n\n    # Edge cases\n    assert engine.calculate_discount(Decimal(\"100.00\"), Decimal(\"0.00\")) == Decimal(\n        \"100.00\"\n    )\n    assert engine.calculate_discount(Decimal(\"100.00\"), Decimal(\"100.00\")) == Decimal(\n        \"0.00\"\n    )\n\n    # Error cases\n    try:\n        engine.calculate_discount(Decimal(\"100.00\"), Decimal(\"101.00\"))\n        assert False, \"Should raise ValueError\"\n    except ValueError as e:\n        assert str(e) == \"Percentage must be between 0 and 100\"\n</code></pre>"},{"location":"python/tests/intro/#2-integration-tests-component-harmony","title":"2. Integration Tests: Component Harmony","text":"<p>Integration tests verify that components work together correctly. They catch interface mismatches and data flow issues.</p> <pre><code>from typing import Optional\nfrom dataclasses import dataclass\nfrom decimal import Decimal\n\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: Decimal\n\n\nclass ProductDatabase:\n    def __init__(self) -&gt; None:\n        self._products: dict[str, Product] = {}\n\n    def add(self, product: Product) -&gt; None:\n        self._products[product.id] = product\n\n    def get(self, product_id: str) -&gt; Optional[Product]:\n        return self._products.get(product_id)\n\n\nclass PricingService:\n    def __init__(self, db: ProductDatabase, engine: PricingEngine) -&gt; None:\n        self.db = db\n        self.engine = engine\n\n    def apply_discount(self, product_id: str, discount: Decimal) -&gt; Optional[Product]:\n        \"\"\"Apply discount to product price.\n\n        Args:\n            product_id: Product identifier\n            discount: Discount percentage\n\n        Returns:\n            Updated product or None if not found\n        \"\"\"\n        product = self.db.get(product_id)\n        if not product:\n            return None\n\n        discounted_price = self.engine.calculate_discount(product.price, discount)\n        return Product(product.id, product.name, discounted_price)\n\n\ndef test_pricing_service_integration() -&gt; None:\n    \"\"\"Demonstrate integration testing.\"\"\"\n    # Setup components\n    db = ProductDatabase()\n    engine = PricingEngine()\n    service = PricingService(db, engine)\n\n    # Prepare test data\n    original_product = Product(\"PROD1\", \"Test Product\", Decimal(\"100.00\"))\n    db.add(original_product)\n\n    # Test integrated flow\n    discounted_product = service.apply_discount(\"PROD1\", Decimal(\"20.00\"))\n    assert discounted_product is not None\n    assert discounted_product.price == Decimal(\"80.00\")\n\n    # Test error handling\n    assert service.apply_discount(\"NONEXISTENT\", Decimal(\"20.00\")) is None\n</code></pre>"},{"location":"python/tests/intro/#3-functional-tests-user-perspective","title":"3. Functional Tests: User Perspective","text":"<p>Functional tests validate complete features from a user's perspective. They ensure the system works as a whole.</p> <pre><code>from fastapi import FastAPI, HTTPException\nfrom fastapi.testclient import TestClient\nfrom decimal import Decimal\nfrom typing import Dict, Any\n\napp = FastAPI()\ndb = ProductDatabase()\nengine = PricingEngine()\nservice = PricingService(db, engine)\n\n\n@app.post(\"/products/{product_id}/discount\")\nasync def apply_discount(\n    product_id: str, discount_percentage: Decimal\n) -&gt; Dict[str, Any]:\n    \"\"\"Apply discount to product.\"\"\"\n    result = service.apply_discount(product_id, discount_percentage)\n    if not result:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    return {\n        \"id\": result.id,\n        \"name\": result.name,\n        \"original_price\": str(result.price),\n        \"discount_percentage\": str(discount_percentage),\n        \"final_price\": str(result.price),\n    }\n\n\ndef test_discount_api() -&gt; None:\n    \"\"\"Demonstrate functional testing of the API.\"\"\"\n    client = TestClient(app)\n\n    # Setup test data\n    db.add(Product(\"PROD1\", \"Test Product\", Decimal(\"100.00\")))\n\n    # Test successful discount\n    response = client.post(\"/products/PROD1/discount?discount_percentage=20.0\")\n    assert response.status_code == 200\n    data = response.json()\n    assert data[\"final_price\"] == \"80.00\"\n\n    # Test error handling\n    response = client.post(\"/products/NONEXISTENT/discount?discount_percentage=20.0\")\n    assert response.status_code == 404\n</code></pre>"},{"location":"python/tests/intro/#testing-best-practices","title":"Testing Best Practices","text":"<ol> <li> <p>Test Organization</p> <ul> <li>One test file per source file</li> <li>Group related tests in classes</li> <li>Name tests descriptively</li> </ul> </li> <li> <p>Test Coverage</p> <ul> <li>Happy path: Normal operation</li> <li>Edge cases: Boundary conditions</li> <li>Error cases: Expected failures</li> <li>Security: Input validation</li> </ul> </li> <li> <p>Performance</p> <ul> <li>Use appropriate test scopes</li> <li>Mock expensive operations</li> <li>Parallelize test execution</li> </ul> </li> </ol>"},{"location":"python/tests/intro/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Incomplete Testing</p> <pre><code># BAD: Only testing happy path\ndef test_incomplete():\n    assert calculate_discount(100, 20) == 80\n\n\n# GOOD: Testing all scenarios\ndef test_complete():\n    assert calculate_discount(100, 20) == 80  # Happy path\n    assert calculate_discount(100, 0) == 100  # Edge case\n    with pytest.raises(ValueError):  # Error case\n        calculate_discount(100, -1)\n</code></pre> </li> <li> <p>Brittle Tests</p> <pre><code># BAD: Testing implementation details\ndef test_brittle(mocker):\n    mocker.spy(service, \"_internal_calculation\")\n    service.process()\n    assert service._internal_calculation.called\n\n\n# GOOD: Testing observable behavior\ndef test_robust():\n    result = service.process()\n    assert result.status == \"success\"\n</code></pre> </li> <li> <p>Poor Isolation</p> <pre><code># BAD: Shared state between tests\ntotal = 0\n\n\ndef test_shared_state1():\n    global total\n    total += 1\n    assert total == 1\n\n\n# GOOD: Isolated tests\ndef test_isolated1():\n    calculator = Calculator()\n    assert calculator.add(1) == 1\n</code></pre> </li> </ol>"},{"location":"python/tests/intro/#resources","title":"Resources","text":"<ul> <li>pytest Documentation</li> <li>Testing Best Practices</li> <li>Property-Based Testing</li> </ul>"},{"location":"python/typing/intro/","title":"Introduction to Python Type Hints","text":""},{"location":"python/typing/intro/#overview","title":"Overview","text":"<p>Consider the following code block.</p> <pre><code>def process_smiles(smiles):\n    # a lot of lines of code\n    ...\n</code></pre> <p>You probably can infer that this function expects SMILES and performs some operations on them. But does it take one SMILES string or does it take a list of those strings? Or can it take both? Compare this to:</p> <pre><code>def process_smiles_v1(smiles:str) -&gt; float:\n    ...\n# or \ndef process_smiles_v2(smiles:list[str]) -&gt; list[int]:\n    ...\n</code></pre> <p>although same information could be stored in a docstring, a type annotation is like a shortcut. As a side bonus, if you try to write:</p> <pre><code>process_smiles_v2(\"CCO\")\n</code></pre> <p>a type checker will throw an error which will allow you to catch this bug even before you run the code.</p> <p>Extra benefits of typing</p> <p>Besides catching errors early and improving readability of your code, a huge benefit of type hints is that it improves your experience with LLMs. Higher quality codebases tend to have type annotations, so if your existing code has the type hints, it'll direct LLM into the portion of the latent space that corresponds to higher code quality (just like a math problem written with LaTeX symbols has a higher chance of getting correct result).</p> <p>Info</p> <ul> <li>Python 3.9+</li> <li>Basic Python knowledge</li> <li>A type checker (mypy, pytype, or Pyright). I tend to use mypy</li> </ul>"},{"location":"python/typing/intro/#basic-usage","title":"Basic Usage","text":""},{"location":"python/typing/intro/#1-simple-type-annotations","title":"1. Simple Type Annotations","text":"<p>Type annotations are optional when the type can be inferred from the initial value.</p> <pre><code>name = \"Alice\"  # Type inferred as str\nage = 25  # Type inferred as int\nis_active = True  # Type inferred as bool\n</code></pre> <p>However, explicit annotations are recommended for empty collections or when type is ambiguous</p> <pre><code>users: list[str] = [] # list of strings\ncache: dict[str, int] = {} # dict mapping str keys to int vals\nnumbers: list[float | int] = []    \n\n# Function annotations are always recommended for clarity\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\ndef multiply(x: int, y: int) -&gt; int:\n    return x * y\n</code></pre>"},{"location":"python/typing/intro/#2-built-in-collections","title":"2. Built-in Collections","text":"<pre><code># Lists\nnumbers: list[int] = [1, 2, 3]\n\n\ndef get_users() -&gt; list[str]:\n    return [\"Alice\", \"Bob\", \"Charlie\"]\n\n\n# Dictionaries\nscores: dict[str, int] = {\"Alice\": 95, \"Bob\": 85}\n\n\ndef get_config() -&gt; dict[str, str]:\n    return {\"host\": \"localhost\", \"port\": \"8080\"}\n\n\n# Sets and Tuples\nvalid_codes: set[int] = {200, 201, 204}\npoint: tuple[float, float] = (2.0, 3.0)\n</code></pre>"},{"location":"python/typing/intro/#3-nullable-types-and-default-values","title":"3. Nullable Types and Default Values","text":"<p>If a variable may have type A or B, a union operator <code>|</code> can be used:</p> <pre><code># Parameters that might be None\ndef find_user(user_id: str | None) -&gt; str:\n    if user_id is None:\n        return \"Guest\"\n    return f\"User {user_id}\"\n</code></pre> <p>default values can be specified after the type:</p> <pre><code>def connect(host: str = \"localhost\", port: int = 8080) -&gt; bool:\n    return True\n</code></pre> <p>Old type annotation syntax</p> <p>Before python 3.9, a union of types was shown as <code>Union[str, None]</code>. An optional value, e.g. <code>user_id: str | None = None</code> was written <code>user_id: Optional[str] = None</code> with an import <code>from typing import Union, Optional</code>. You might see this syntax in older codebases; the new one is recommended. If you're up for a rabbit hole, python core devs had a holy war over this change.</p>"},{"location":"python/typing/intro/#4-multiple-return-types","title":"4. Multiple Return Types","text":"<pre><code>def parse_value(value: str) -&gt; int | float:\n    \"\"\"Parse a string into either an integer or float.\"\"\"\n    try:\n        return int(value)\n    except ValueError:\n        return float(value)\n\n\ndef fetch_user_data(user_id: int) -&gt; dict[str, str | int] | None:\n    \"\"\"Fetch user data, returns None if user not found.\"\"\"\n    if user_id &lt; 0:\n        return None\n    return {\"name\": \"Alice\", \"age\": 25}\n</code></pre>"},{"location":"python/typing/intro/#5-type-aliases","title":"5. Type Aliases","text":"<p>Type aliases help manage complex type annotations and make code more readable:</p> <pre><code># Type aliases for complex types\nUserId = int\nUserDict = dict[UserId, str]\nJsonValue = str | int | float | bool | None\nJsonObject = dict[str, JsonValue]\n\n\ndef process_json(data: JsonObject) -&gt; list[str]:\n    \"\"\"Process a JSON object and return list of keys with string values.\"\"\"\n    return [k for k, v in data.items() if isinstance(v, str)]\n\n\ndef get_user_data() -&gt; UserDict:\n    return {1: \"Alice\", 2: \"Bob\"}\n</code></pre>"},{"location":"python/typing/intro/#type-checking-in-practice","title":"Type Checking in Practice","text":""},{"location":"python/typing/intro/#static-vs-runtime-type-checking","title":"Static vs Runtime Type Checking","text":"<p>Type hints enable static analysis of your code before execution. This creates two distinct phases of type checking:</p> <ol> <li> <p>Static Analysis (Before Runtime):</p> <ul> <li>Checks type consistency</li> <li>Validates function signatures</li> <li>Ensures type-safe operations</li> <li>No performance impact at runtime</li> </ul> </li> <li> <p>Runtime Behavior (During Execution):</p> <ul> <li>Python's normal dynamic type checking</li> <li>No overhead from type hints (they're ignored)</li> <li>Actual type enforcement</li> </ul> </li> </ol> <p>Here's how this dual system works:</p> <pre><code>def process_items(items: list[str]) -&gt; dict[str, int]:\n    \"\"\"Process a list of strings and return their lengths.\"\"\"\n    return {item: len(item) for item in items}\n\n\n# Static type checker catches these errors:\nprocess_items([1, 2, 3])  # Error: list[int] is not list[str]\nprocess_items(\"not a list\")  # Error: str is not list[str]\n\n\n# Runtime errors (not caught by static checker):\ndef load_and_process_data(filepath: str) -&gt; dict[str, int]:\n    \"\"\"Load data from a file and process it.\n\n    The type checker trusts our annotation that the file contains strings,\n    but at runtime, the file might contain any type of data.\n    \"\"\"\n    with open(filepath) as f:\n        # Type checker assumes this creates List[str] based on annotation\n        items: list[str] = f.read().splitlines()\n        return process_items(items)\n\n\n# These will pass type checking but might fail at runtime:\nload_and_process_data(\"data.txt\")\n# Runtime error if file contains non-string data or if file doesn't exist\n</code></pre> <p>The key difference is:</p> <ul> <li>Static type checking validates code structure and explicit type annotations</li> <li>Runtime checks validate actual data values and operations</li> <li>External data (files, network, user input) can't be verified by the type checker</li> </ul>"},{"location":"python/typing/intro/#common-type-checking-scenarios","title":"Common Type Checking Scenarios","text":"<p>Here are realistic examples of issues that type checkers catch:</p> <pre><code># Function argument mismatches\ndef calculate_average(numbers: list[float]) -&gt; float:\n    return sum(numbers) / len(numbers)\n\n\ndata = [\"1\", \"2\", \"3\"]  # Error: list[str] incompatible with List[float]\ncalculate_average(data)\n\n\n# Incorrect attribute access\nclass User:\n    def __init__(self, name: str):\n        self.name = name\n\n\ndef print_email(user: User) -&gt; None:\n    print(user.email)  # Error: 'User' has no attribute 'email'\n\n\n# Type narrowing errors\ndef process_value(value: str | int) -&gt; str:\n    if isinstance(value, int):\n        return value.upper()  # Error: 'int' has no attribute 'upper'\n    return value.upper()\n\n\n# Container type mismatches\ncache: dict[str, list[int]] = {\n    \"numbers\": [\"1\", \"2\", \"3\"]  # Error: list[str] incompatible with list[int]\n}\n\n\n# Function return type violations\ndef get_user_ids() -&gt; list[int]:\n    users = {\"1\": \"Alice\", \"2\": \"Bob\"}\n    return list(users.keys())  # Error: list[str] incompatible with list[int]\n</code></pre>"},{"location":"python/typing/intro/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always Annotate Public APIs</p> <ul> <li>Functions and methods exposed to other modules</li> <li>Class attributes and properties</li> <li>Module-level variables</li> </ul> </li> <li> <p>Use Type Aliases for Complex Types</p> <pre><code>from typing import TypeAlias\n\nJsonDict: TypeAlias = dict[str, str | int | float | bool | None]\n</code></pre> </li> <li> <p>Handle Optional Types Safely</p> <pre><code>def process_data(data: str | None) -&gt; str:\n    if data is None:\n        return \"No data\"\n    return data.upper()\n</code></pre> </li> <li> <p>Document Type Variables</p> <pre><code>from typing import TypeVar\n\nT = TypeVar(\"T\", str, int)  # T can be str or int\n\n\ndef first_element(lst: list[T]) -&gt; T:\n    return lst[0]\n</code></pre> </li> </ol>"},{"location":"python/typing/intro/#configuring-mypy","title":"Configuring mypy","text":"<p>Enabling an automatic type checker for your codebase is quite easy. Simply <code>uv add mypy</code> in your venv, and then you can run <code>mypy .</code>. Once your codebase satisfies basic rules (checked by <code>mypy .</code> call), you can try &amp; run <code>mypy --strict .</code>.</p> <p>You can also update your <code>pyproject.toml</code> (alredy done in python-template) to have strict enabled by default.</p> <pre><code>[tool.mypy]\nstrict = true\nexclude = [\"tests\"]                    # specifies which directories are not checked\nignore_missing_imports = true          # so that it doesn't complain about types in external libraries\ndisable_error_code = [\"unused-ignore\"]\n</code></pre> <p>If you start introducing types to your existing codebase, you might get quite discourage by the seeming amount of effort to fix 100s of mypy strict errors. I can only say that I personally went through that experience twice, after which I could write new code with type hints present by default, which made my code better and more reliable.</p>"},{"location":"python/typing/intro/#summary","title":"Summary","text":"<p>Type hints are a powerful tool for improving code clarity, reducing bugs, and ensuring robust software development. Whether you're working on a small script or a large-scale project, leveraging Python's type system can significantly enhance your development process.</p>"}]}